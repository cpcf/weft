// Code generated by gogenkit. DO NOT EDIT.

package {{.API.Package}}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// Client provides access to the {{.API.Name}} API
type Client struct {
	baseURL    string
	httpClient *http.Client
	authToken  string
	userAgent  string
}

// ClientOption represents a configuration option for the client
type ClientOption func(*Client)

// NewClient creates a new {{.API.Name}} API client
func NewClient(options ...ClientOption) *Client {
	client := &Client{
		baseURL: "{{.API.BaseURL}}",
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		userAgent: "{{kebab .API.Name}}-go-client/{{.API.Version}}",
	}

	for _, option := range options {
		option(client)
	}

	return client
}

// WithBaseURL sets the base URL for API requests
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) {
		c.baseURL = strings.TrimSuffix(baseURL, "/")
	}
}

// WithHTTPClient sets the HTTP client to use for requests
func WithHTTPClient(httpClient *http.Client) ClientOption {
	return func(c *Client) {
		c.httpClient = httpClient
	}
}

{{- if eq .API.Auth.Type "bearer"}}
// WithBearerToken sets the bearer token for authentication
func WithBearerToken(token string) ClientOption {
	return func(c *Client) {
		c.authToken = token
	}
}
{{- else if eq .API.Auth.Type "apikey"}}
// WithAPIKey sets the API key for authentication
func WithAPIKey(apiKey string) ClientOption {
	return func(c *Client) {
		c.authToken = apiKey
	}
}
{{- end}}

// WithUserAgent sets the User-Agent header for requests
func WithUserAgent(userAgent string) ClientOption {
	return func(c *Client) {
		c.userAgent = userAgent
	}
}

{{range .API.Endpoints}}
// {{.Name}} {{.Description}}
func (c *Client) {{.Name}}(ctx context.Context{{range .Parameters}}{{if .Required}}, {{camel .Name}} {{.Type}}{{end}}{{end}}{{if .Request}}, req {{.Request.Type}}{{end}}{{range .Parameters}}{{if not .Required}}, {{camel .Name}} *{{.Type}}{{end}}{{end}}) ({{if .Response.IsArray}}[]{{end}}{{if .Response.IsPointer}}*{{end}}{{.Response.Type}}, error) {
	// Build URL path
	path := "{{.Path}}"
	{{- range .Parameters}}
	{{- if eq .In "path"}}
	path = strings.ReplaceAll(path, "{{print "{" .Name "}"}}","{{if eq .Type "string"}}{{camel .Name}}{{else if eq .Type "int64"}}strconv.FormatInt({{camel .Name}}, 10){{else if eq .Type "int"}}strconv.Itoa({{camel .Name}}){{else}}strconv.FormatBool({{camel .Name}}){{end}}")
	{{- end}}
	{{- end}}
	
	// Build URL
	u, err := url.Parse(c.baseURL + path)
	if err != nil {
		return {{if .Response.IsArray}}nil{{else}}{{if eq .Response.Type "bool"}}false{{else}}{{if .Response.IsPointer}}nil{{else}}{{.Response.Type}}{}{{end}}{{end}}{{end}}, NewClientError("parse_url", err)
	}
	
	{{- $hasQueryParams := false}}
	{{- range .Parameters}}{{if eq .In "query"}}{{$hasQueryParams = true}}{{end}}{{end}}
	{{- if $hasQueryParams}}
	// Add query parameters
	query := u.Query()
	{{- range .Parameters}}
	{{- if eq .In "query"}}
	{{- if .Required}}
	{{- if eq .Type "string"}}
	query.Set("{{.Name}}", {{camel .Name}})
	{{- else if eq .Type "int"}}
	query.Set("{{.Name}}", strconv.Itoa({{camel .Name}}))
	{{- else if eq .Type "int64"}}
	query.Set("{{.Name}}", strconv.FormatInt({{camel .Name}}, 10))
	{{- else}}
	query.Set("{{.Name}}", {{camel .Name}}.String())
	{{- end}}
	{{- else}}
	if {{camel .Name}} != nil {
		{{- if eq .Type "string"}}
		query.Set("{{.Name}}", *{{camel .Name}})
		{{- else if eq .Type "int"}}
		query.Set("{{.Name}}", strconv.Itoa(*{{camel .Name}}))
		{{- else if eq .Type "int64"}}
		query.Set("{{.Name}}", strconv.FormatInt(*{{camel .Name}}, 10))
		{{- else}}
		query.Set("{{.Name}}", (*{{camel .Name}}).String())
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- end}}
	u.RawQuery = query.Encode()
	{{- end}}
	
	{{- if .Request}}
	// Serialize request body
	var body io.Reader
	if req != ({{.Request.Type}}{}) {
		jsonData, err := json.Marshal(req)
		if err != nil {
			return {{if .Response.IsArray}}nil{{else}}{{if eq .Response.Type "bool"}}false{{else}}{{if .Response.IsPointer}}nil{{else}}{{.Response.Type}}{}{{end}}{{end}}{{end}}, NewClientError("marshal_request", err)
		}
		body = bytes.NewReader(jsonData)
	}
	{{- end}}
	
	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "{{.Method}}", u.String(), {{if .Request}}body{{else}}nil{{end}})
	if err != nil {
		return {{if .Response.IsArray}}nil{{else}}{{if eq .Response.Type "bool"}}false{{else}}{{if .Response.IsPointer}}nil{{else}}{{.Response.Type}}{}{{end}}{{end}}{{end}}, NewClientError("create_request", err)
	}
	
	// Set headers
	{{- if .Request}}
	httpReq.Header.Set("Content-Type", "application/json")
	{{- end}}
	httpReq.Header.Set("User-Agent", c.userAgent)
	httpReq.Header.Set("Accept", "application/json")
	
	{{- if eq $.API.Auth.Type "bearer"}}
	// Set authorization header
	if c.authToken != "" {
		httpReq.Header.Set("{{$.API.Auth.Header}}", "Bearer "+c.authToken)
	}
	{{- else if eq $.API.Auth.Type "apikey"}}
	// Set API key header
	if c.authToken != "" {
		httpReq.Header.Set("{{$.API.Auth.Header}}", c.authToken)
	}
	{{- end}}
	
	{{- $hasHeaderParams := false}}
	{{- range .Parameters}}{{if eq .In "header"}}{{$hasHeaderParams = true}}{{end}}{{end}}
	{{- if $hasHeaderParams}}
	// Set custom headers
	{{- range .Parameters}}
	{{- if eq .In "header"}}
	{{- if .Required}}
	httpReq.Header.Set("{{.Name}}", {{if eq .Type "string"}}{{camel .Name}}{{else}}fmt.Sprintf("%v", {{camel .Name}}){{end}})
	{{- else}}
	if {{camel .Name}} != nil {
		httpReq.Header.Set("{{.Name}}", {{if eq .Type "string"}}*{{camel .Name}}{{else}}fmt.Sprintf("%v", *{{camel .Name}}){{end}})
	}
	{{- end}}
	{{- end}}
	{{- end}}
	{{- end}}
	
	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return {{if .Response.IsArray}}nil{{else}}{{if eq .Response.Type "bool"}}false{{else}}{{if .Response.IsPointer}}nil{{else}}{{.Response.Type}}{}{{end}}{{end}}{{end}}, NewClientError("execute_request", err)
	}
	defer resp.Body.Close()
	
	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return {{if .Response.IsArray}}nil{{else}}{{if eq .Response.Type "bool"}}false{{else}}{{if .Response.IsPointer}}nil{{else}}{{.Response.Type}}{}{{end}}{{end}}{{end}}, NewClientError("read_response", err)
	}
	
	// Handle error responses
	if resp.StatusCode >= 400 {
		apiErr := &APIError{
			StatusCode: resp.StatusCode,
		}
		
		if len(respBody) > 0 {
			if err := json.Unmarshal(respBody, apiErr); err != nil {
				// Fallback to simple message
				apiErr.Message = string(respBody)
			}
		} else {
			apiErr.Message = http.StatusText(resp.StatusCode)
		}
		
		return {{if .Response.IsArray}}nil{{else}}{{if eq .Response.Type "bool"}}false{{else}}{{if .Response.IsPointer}}nil{{else}}{{.Response.Type}}{}{{end}}{{end}}{{end}}, apiErr
	}
	
	{{- if eq .Response.Type "bool"}}
	// Boolean response - success means true
	return resp.StatusCode >= 200 && resp.StatusCode < 300, nil
	{{- else}}
	// Parse response
	{{- if .Response.IsArray}}
	var result []{{.Response.Type}}
	{{- else}}
	{{- if .Response.IsPointer}}
	var result *{{.Response.Type}}
	{{- else}}
	var result {{.Response.Type}}
	{{- end}}
	{{- end}}
	
	if len(respBody) > 0 {
		if err := json.Unmarshal(respBody, &result); err != nil {
			return {{if .Response.IsArray}}nil{{else}}{{if .Response.IsPointer}}nil{{else}}{{.Response.Type}}{}{{end}}{{end}}, NewClientError("unmarshal_response", err)
		}
	}
	
	return result, nil
	{{- end}}
}
{{end}}