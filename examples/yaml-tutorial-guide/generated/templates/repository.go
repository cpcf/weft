// Code generated by weft. DO NOT EDIT.

package ecommerce

import (
	"database/sql"
	"fmt"
	"time"
)

// Database connection and configuration
type DB struct {
	conn   *sql.DB
	config DatabaseConfig
}

// DatabaseConfig holds database connection parameters
type DatabaseConfig struct {
	Driver string
	Host   string
	Port   int
	Name   string
}

// NewDB creates a new database connection
func NewDB() (*DB, error) {
	config := DatabaseConfig{
		Driver: "postgres",
		Host:   "localhost",
		Port:   5432,
		Name:   "ecommerce_db",
	}

	// Build connection string based on driver
	var connStr string
	switch config.Driver {
	case "postgres":
		connStr = fmt.Sprintf("postgres://%s:%d/%s?sslmode=disable",
			config.Host, config.Port, config.Name)
	case "mysql":
		connStr = fmt.Sprintf("%s:%d/%s", config.Host, config.Port, config.Name)
	case "sqlite":
		connStr = config.Name
	default:
		return nil, fmt.Errorf("unsupported database driver: %s", config.Driver)
	}

	conn, err := sql.Open(config.Driver, connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	return &DB{
		conn:   conn,
		config: config,
	}, nil
}

// Close closes the database connection
func (db *DB) Close() error {
	return db.conn.Close()
}

// UsersRepository provides database operations for users
type UsersRepository struct {
	db *DB
}

// NewUsersRepository creates a new repository instance
func NewUsersRepository(db *DB) *UsersRepository {
	return &UsersRepository{db: db}
}

// Create inserts a new users record
func (r *UsersRepository) Create(users *Users) error {
	// Set timestamps if fields exist
	users.Created_at = time.Now()
	users.Updated_at = time.Now()

	// Simple INSERT query - in production you'd build this dynamically
	_, err := r.db.conn.Exec("INSERT INTO users DEFAULT VALUES")
	return err
}

// GetByID retrieves a users by its primary key
func (r *UsersRepository) GetByID(id interface{}) (*Users, error) {
	query := `SELECT id, email, first_name, last_name, password_hash, role, is_active, created_at, updated_at,  FROM users WHERE id = $1`

	var users Users
	err := r.db.conn.QueryRow(query, id).Scan(
		&users.Id,
		&users.Email,
		&users.First_name,
		&users.Last_name,
		&users.Password_hash,
		&users.Role,
		&users.Is_active,
		&users.Created_at,
		&users.Updated_at,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return &users, nil
}

// List retrieves all users with optional pagination
func (r *UsersRepository) List(limit, offset int) ([]*Users, error) {
	query := `SELECT id, email, first_name, last_name, password_hash, role, is_active, created_at, updated_at,  FROM users ORDER BY id LIMIT $1 OFFSET $2`

	rows, err := r.db.conn.Query(query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*Users
	for rows.Next() {
		var users Users
		err := rows.Scan(
			&users.Id,
			&users.Email,
			&users.First_name,
			&users.Last_name,
			&users.Password_hash,
			&users.Role,
			&users.Is_active,
			&users.Created_at,
			&users.Updated_at,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, &users)
	}

	return results, rows.Err()
}

// CategoriesRepository provides database operations for categories
type CategoriesRepository struct {
	db *DB
}

// NewCategoriesRepository creates a new repository instance
func NewCategoriesRepository(db *DB) *CategoriesRepository {
	return &CategoriesRepository{db: db}
}

// Create inserts a new categories record
func (r *CategoriesRepository) Create(categories *Categories) error {
	// Set timestamps if fields exist
	categories.Created_at = time.Now()

	// Simple INSERT query - in production you'd build this dynamically
	_, err := r.db.conn.Exec("INSERT INTO categories DEFAULT VALUES")
	return err
}

// GetByID retrieves a categories by its primary key
func (r *CategoriesRepository) GetByID(id interface{}) (*Categories, error) {
	query := `SELECT id, name, slug, description, parent_id, created_at,  FROM categories WHERE id = $1`

	var categories Categories
	err := r.db.conn.QueryRow(query, id).Scan(
		&categories.Id,
		&categories.Name,
		&categories.Slug,
		&categories.Description,
		&categories.Parent_id,
		&categories.Created_at,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return &categories, nil
}

// List retrieves all categories with optional pagination
func (r *CategoriesRepository) List(limit, offset int) ([]*Categories, error) {
	query := `SELECT id, name, slug, description, parent_id, created_at,  FROM categories ORDER BY id LIMIT $1 OFFSET $2`

	rows, err := r.db.conn.Query(query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*Categories
	for rows.Next() {
		var categories Categories
		err := rows.Scan(
			&categories.Id,
			&categories.Name,
			&categories.Slug,
			&categories.Description,
			&categories.Parent_id,
			&categories.Created_at,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, &categories)
	}

	return results, rows.Err()
}

// ProductsRepository provides database operations for products
type ProductsRepository struct {
	db *DB
}

// NewProductsRepository creates a new repository instance
func NewProductsRepository(db *DB) *ProductsRepository {
	return &ProductsRepository{db: db}
}

// Create inserts a new products record
func (r *ProductsRepository) Create(products *Products) error {
	// Set timestamps if fields exist
	products.Created_at = time.Now()
	products.Updated_at = time.Now()

	// Simple INSERT query - in production you'd build this dynamically
	_, err := r.db.conn.Exec("INSERT INTO products DEFAULT VALUES")
	return err
}

// GetByID retrieves a products by its primary key
func (r *ProductsRepository) GetByID(id interface{}) (*Products, error) {
	query := `SELECT id, category_id, name, slug, description, price, stock_quantity, sku, is_active, metadata, created_at, updated_at,  FROM products WHERE id = $1`

	var products Products
	err := r.db.conn.QueryRow(query, id).Scan(
		&products.Id,
		&products.Category_id,
		&products.Name,
		&products.Slug,
		&products.Description,
		&products.Price,
		&products.Stock_quantity,
		&products.Sku,
		&products.Is_active,
		&products.Metadata,
		&products.Created_at,
		&products.Updated_at,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return &products, nil
}

// List retrieves all products with optional pagination
func (r *ProductsRepository) List(limit, offset int) ([]*Products, error) {
	query := `SELECT id, category_id, name, slug, description, price, stock_quantity, sku, is_active, metadata, created_at, updated_at,  FROM products ORDER BY id LIMIT $1 OFFSET $2`

	rows, err := r.db.conn.Query(query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*Products
	for rows.Next() {
		var products Products
		err := rows.Scan(
			&products.Id,
			&products.Category_id,
			&products.Name,
			&products.Slug,
			&products.Description,
			&products.Price,
			&products.Stock_quantity,
			&products.Sku,
			&products.Is_active,
			&products.Metadata,
			&products.Created_at,
			&products.Updated_at,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, &products)
	}

	return results, rows.Err()
}

// OrdersRepository provides database operations for orders
type OrdersRepository struct {
	db *DB
}

// NewOrdersRepository creates a new repository instance
func NewOrdersRepository(db *DB) *OrdersRepository {
	return &OrdersRepository{db: db}
}

// Create inserts a new orders record
func (r *OrdersRepository) Create(orders *Orders) error {
	// Set timestamps if fields exist
	orders.Created_at = time.Now()
	orders.Updated_at = time.Now()

	// Simple INSERT query - in production you'd build this dynamically
	_, err := r.db.conn.Exec("INSERT INTO orders DEFAULT VALUES")
	return err
}

// GetByID retrieves a orders by its primary key
func (r *OrdersRepository) GetByID(id interface{}) (*Orders, error) {
	query := `SELECT id, user_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at,  FROM orders WHERE id = $1`

	var orders Orders
	err := r.db.conn.QueryRow(query, id).Scan(
		&orders.Id,
		&orders.User_id,
		&orders.Order_number,
		&orders.Status,
		&orders.Total_amount,
		&orders.Shipping_address,
		&orders.Billing_address,
		&orders.Notes,
		&orders.Created_at,
		&orders.Updated_at,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return &orders, nil
}

// List retrieves all orders with optional pagination
func (r *OrdersRepository) List(limit, offset int) ([]*Orders, error) {
	query := `SELECT id, user_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at,  FROM orders ORDER BY id LIMIT $1 OFFSET $2`

	rows, err := r.db.conn.Query(query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*Orders
	for rows.Next() {
		var orders Orders
		err := rows.Scan(
			&orders.Id,
			&orders.User_id,
			&orders.Order_number,
			&orders.Status,
			&orders.Total_amount,
			&orders.Shipping_address,
			&orders.Billing_address,
			&orders.Notes,
			&orders.Created_at,
			&orders.Updated_at,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, &orders)
	}

	return results, rows.Err()
}

// Order_itemsRepository provides database operations for order_items
type Order_itemsRepository struct {
	db *DB
}

// NewOrder_itemsRepository creates a new repository instance
func NewOrder_itemsRepository(db *DB) *Order_itemsRepository {
	return &Order_itemsRepository{db: db}
}

// Create inserts a new order_items record
func (r *Order_itemsRepository) Create(order_items *Order_items) error {
	// Set timestamps if fields exist
	order_items.Created_at = time.Now()

	// Simple INSERT query - in production you'd build this dynamically
	_, err := r.db.conn.Exec("INSERT INTO order_items DEFAULT VALUES")
	return err
}

// GetByID retrieves a order_items by its primary key
func (r *Order_itemsRepository) GetByID(id interface{}) (*Order_items, error) {
	query := `SELECT id, order_id, product_id, quantity, unit_price, total_price, created_at,  FROM order_items WHERE id = $1`

	var order_items Order_items
	err := r.db.conn.QueryRow(query, id).Scan(
		&order_items.Id,
		&order_items.Order_id,
		&order_items.Product_id,
		&order_items.Quantity,
		&order_items.Unit_price,
		&order_items.Total_price,
		&order_items.Created_at,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return &order_items, nil
}

// List retrieves all order_items with optional pagination
func (r *Order_itemsRepository) List(limit, offset int) ([]*Order_items, error) {
	query := `SELECT id, order_id, product_id, quantity, unit_price, total_price, created_at,  FROM order_items ORDER BY id LIMIT $1 OFFSET $2`

	rows, err := r.db.conn.Query(query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*Order_items
	for rows.Next() {
		var order_items Order_items
		err := rows.Scan(
			&order_items.Id,
			&order_items.Order_id,
			&order_items.Product_id,
			&order_items.Quantity,
			&order_items.Unit_price,
			&order_items.Total_price,
			&order_items.Created_at,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, &order_items)
	}

	return results, rows.Err()
}
