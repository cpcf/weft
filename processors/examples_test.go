package processors

import (
	"testing"
)

func TestTrimWhitespace_ProcessContent(t *testing.T) {
	processor := NewTrimWhitespace()

	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "trims trailing spaces",
			input:    "line1   \nline2\t\t\nline3\n",
			expected: "line1\nline2\nline3\n",
		},
		{
			name:     "no trailing whitespace",
			input:    "line1\nline2\nline3\n",
			expected: "line1\nline2\nline3\n",
		},
		{
			name:     "empty lines",
			input:    "line1\n   \nline3\n",
			expected: "line1\n\nline3\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := processor.ProcessContent("test.txt", []byte(tt.input))
			if err != nil {
				t.Fatalf("ProcessContent() error = %v", err)
			}

			if string(result) != tt.expected {
				t.Errorf("ProcessContent() = %q, want %q", string(result), tt.expected)
			}
		})
	}
}

func TestAddGeneratedHeader_ProcessContent(t *testing.T) {
	tests := []struct {
		name      string
		processor *AddGeneratedHeader
		filePath  string
		input     string
		want      string
	}{
		{
			name:      "adds header to go file",
			processor: NewAddGeneratedHeader("testgen", ".go"),
			filePath:  "main.go",
			input:     "package main\n",
			want:      "// Code generated by testgen. DO NOT EDIT.\n\npackage main\n",
		},
		{
			name:      "skips non-matching file type",
			processor: NewAddGeneratedHeader("testgen", ".go"),
			filePath:  "main.js",
			input:     "console.log('hello');\n",
			want:      "console.log('hello');\n",
		},
		{
			name:      "skips if header already exists",
			processor: NewAddGeneratedHeader("testgen", ".go"),
			filePath:  "main.go",
			input:     "// Code generated by other. DO NOT EDIT.\npackage main\n",
			want:      "// Code generated by other. DO NOT EDIT.\npackage main\n",
		},
		{
			name:      "processes all file types when none specified",
			processor: NewAddGeneratedHeader("testgen"),
			filePath:  "config.yaml",
			input:     "key: value\n",
			want:      "Code generated by testgen. DO NOT EDIT.\n\nkey: value\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := tt.processor.ProcessContent(tt.filePath, []byte(tt.input))
			if err != nil {
				t.Fatalf("ProcessContent() error = %v", err)
			}

			if string(result) != tt.want {
				t.Errorf("ProcessContent() = %q, want %q", string(result), tt.want)
			}
		})
	}
}

func TestRegexReplace_ProcessContent(t *testing.T) {
	processor, err := NewRegexReplace(`TODO: (.+)`, "DONE: $1")
	if err != nil {
		t.Fatalf("NewRegexReplace() error = %v", err)
	}

	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "replaces pattern",
			input:    "TODO: implement feature\nSome other line\nTODO: fix bug",
			expected: "DONE: implement feature\nSome other line\nDONE: fix bug",
		},
		{
			name:     "no matches",
			input:    "No todos here",
			expected: "No todos here",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := processor.ProcessContent("test.txt", []byte(tt.input))
			if err != nil {
				t.Fatalf("ProcessContent() error = %v", err)
			}

			if string(result) != tt.expected {
				t.Errorf("ProcessContent() = %q, want %q", string(result), tt.expected)
			}
		})
	}
}

func TestRegexReplace_WithFilePattern(t *testing.T) {
	processor, err := NewRegexReplace(`foo`, "bar")
	if err != nil {
		t.Fatalf("NewRegexReplace() error = %v", err)
	}

	processor, err = processor.WithFilePattern(`\.go$`)
	if err != nil {
		t.Fatalf("WithFilePattern() error = %v", err)
	}

	tests := []struct {
		name     string
		filePath string
		input    string
		expected string
	}{
		{
			name:     "processes matching file",
			filePath: "main.go",
			input:    "foo bar foo",
			expected: "bar bar bar",
		},
		{
			name:     "skips non-matching file",
			filePath: "main.js",
			input:    "foo bar foo",
			expected: "foo bar foo",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := processor.ProcessContent(tt.filePath, []byte(tt.input))
			if err != nil {
				t.Fatalf("ProcessContent() error = %v", err)
			}

			if string(result) != tt.expected {
				t.Errorf("ProcessContent() = %q, want %q", string(result), tt.expected)
			}
		})
	}
}
