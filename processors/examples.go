package processors

import (
	"bytes"
	"path/filepath"
	"regexp"
	"strings"
)

// TrimWhitespace is a processor that trims trailing whitespace from all lines.
// It's useful for cleaning up generated files.
type TrimWhitespace struct{}

// NewTrimWhitespace creates a new whitespace trimming processor.
func NewTrimWhitespace() *TrimWhitespace {
	return &TrimWhitespace{}
}

// ProcessContent trims trailing whitespace from each line.
func (t *TrimWhitespace) ProcessContent(filePath string, content []byte) ([]byte, error) {
	lines := bytes.Split(content, []byte("\n"))
	for i, line := range lines {
		lines[i] = bytes.TrimRightFunc(line, func(r rune) bool {
			return r == ' ' || r == '\t'
		})
	}
	return bytes.Join(lines, []byte("\n")), nil
}

// AddGeneratedHeader adds a "Code generated" header to files.
// This helps identify generated files and discourages manual editing.
type AddGeneratedHeader struct {
	// Generator is the name of the generator to include in the header
	Generator string
	// FileTypes specifies which file extensions to process (e.g., []string{".go", ".java"})
	// If empty, processes all files
	FileTypes []string
}

// NewAddGeneratedHeader creates a new header processor.
func NewAddGeneratedHeader(generator string, fileTypes ...string) *AddGeneratedHeader {
	return &AddGeneratedHeader{
		Generator: generator,
		FileTypes: fileTypes,
	}
}

// ProcessContent adds a generated header to the beginning of the file.
func (a *AddGeneratedHeader) ProcessContent(filePath string, content []byte) ([]byte, error) {
	if !a.shouldProcess(filePath) {
		return content, nil
	}

	// Check if header already exists
	contentStr := string(content)
	if strings.Contains(contentStr, "Code generated") {
		return content, nil
	}

	header := a.generateHeader(filePath)
	return append([]byte(header), content...), nil
}

// shouldProcess checks if this file type should be processed.
func (a *AddGeneratedHeader) shouldProcess(filePath string) bool {
	if len(a.FileTypes) == 0 {
		return true
	}

	ext := strings.ToLower(filepath.Ext(filePath))
	for _, fileType := range a.FileTypes {
		if ext == strings.ToLower(fileType) {
			return true
		}
	}
	return false
}

// generateHeader creates the appropriate header for the file type.
func (a *AddGeneratedHeader) generateHeader(filePath string) string {
	ext := strings.ToLower(filepath.Ext(filePath))
	generator := a.Generator
	if generator == "" {
		generator = "generator"
	}

	switch ext {
	case ".go":
		return "// Code generated by " + generator + ". DO NOT EDIT.\n\n"
	case ".java":
		return "// Code generated by " + generator + ". DO NOT EDIT.\n\n"
	case ".js", ".ts":
		return "// Code generated by " + generator + ". DO NOT EDIT.\n\n"
	case ".py":
		return "# Code generated by " + generator + ". DO NOT EDIT.\n\n"
	case ".rb":
		return "# Code generated by " + generator + ". DO NOT EDIT.\n\n"
	case ".rs":
		return "// Code generated by " + generator + ". DO NOT EDIT.\n\n"
	default:
		return "Code generated by " + generator + ". DO NOT EDIT.\n\n"
	}
}

// RegexReplace is a processor that applies regex replacements to file content.
// It's useful for custom transformations that can't be easily expressed otherwise.
type RegexReplace struct {
	// Pattern is the regular expression to match
	Pattern *regexp.Regexp
	// Replacement is the replacement string (can include capture groups like $1, $2)
	Replacement string
	// FilePattern optionally limits processing to files matching this pattern
	FilePattern *regexp.Regexp
}

// NewRegexReplace creates a new regex replacement processor.
func NewRegexReplace(pattern, replacement string) (*RegexReplace, error) {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return nil, err
	}

	return &RegexReplace{
		Pattern:     re,
		Replacement: replacement,
	}, nil
}

// WithFilePattern adds a file pattern filter to the processor.
func (r *RegexReplace) WithFilePattern(filePattern string) (*RegexReplace, error) {
	re, err := regexp.Compile(filePattern)
	if err != nil {
		return nil, err
	}
	r.FilePattern = re
	return r, nil
}

// ProcessContent applies the regex replacement to the file content.
func (r *RegexReplace) ProcessContent(filePath string, content []byte) ([]byte, error) {
	// Check file pattern if specified
	if r.FilePattern != nil && !r.FilePattern.MatchString(filePath) {
		return content, nil
	}

	// Apply replacement
	result := r.Pattern.ReplaceAll(content, []byte(r.Replacement))
	return result, nil
}
